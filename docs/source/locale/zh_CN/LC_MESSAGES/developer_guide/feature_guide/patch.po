# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, vllm-ascend team
# This file is distributed under the same license as the vllm-ascend
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version:  vllm-ascend\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-21 10:23+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../source/developer_guide/feature_guide/patch.md:1
msgid "Patch in vLLM Ascend"
msgstr "vLLM Ascend补丁说明"

#: ../../source/developer_guide/feature_guide/patch.md:3
msgid ""
"vLLM Ascend is a platform plugin for vLLM. Due to the different release "
"cycle of vLLM and vLLM Ascend and their hardware limitations, we need to "
"patch some code in vLLM to make it compatible with vLLM Ascend."
msgstr "vLLM Ascend 是 vLLM 的一个平台插件。由于 vLLM 与 vLLM Ascend 的发布周期存在差异，且存在硬件限制，我们需要对 vLLM 的部分代码进行补丁，以使其与 vLLM Ascend 兼容。"

#: ../../source/developer_guide/feature_guide/patch.md:5
msgid ""
"In vLLM Ascend code, we provide a patch module `vllm_ascend/patch` to "
"adapt to changes in vLLM."
msgstr "在 vLLM Ascend 代码中，我们提供了一个补丁模块 `vllm_ascend/patch` 以应对 vLLM 的变更。"

#: ../../source/developer_guide/feature_guide/patch.md:7
msgid "Principle"
msgstr "基本原则"

#: ../../source/developer_guide/feature_guide/patch.md:9
msgid ""
"We should keep in mind that Patch is not the best way to make vLLM Ascend"
" compatible. It's just a temporary solution. The best way is to "
"contribute the change to vLLM to make it compatible with vLLM Ascend "
"initially. In vLLM Ascend, we have the basic principle for Patch "
"strategy:"
msgstr "我们必须明确，补丁并非实现 vLLM Ascend 兼容性的最佳方案，它只是一个临时解决方案。最佳途径是将修改贡献至 vLLM 项目，使其原生支持 vLLM Ascend。在 vLLM Ascend 中，我们遵循以下补丁策略基本原则："

#: ../../source/developer_guide/feature_guide/patch.md:11
msgid "Less is more. Please do not patch unless it's the only way currently."
msgstr "少即是多。除非当前别无他法，否则请勿使用补丁。"

#: ../../source/developer_guide/feature_guide/patch.md:12
msgid ""
"Once a patch is added, it's required to describe the future plan for "
"removing the patch."
msgstr "一旦添加补丁，必须说明未来移除该补丁的计划。"

#: ../../source/developer_guide/feature_guide/patch.md:13
msgid "Anytime, cleaning the patch code is welcome."
msgstr "随时欢迎清理补丁代码。"

#: ../../source/developer_guide/feature_guide/patch.md:15
msgid "How it works"
msgstr "工作机制"

#: ../../source/developer_guide/feature_guide/patch.md:17
msgid "In `vllm_ascend/patch`, you can see the code structure as follows:"
msgstr "在 `vllm_ascend/patch` 目录中，可看到如下代码结构："

#: ../../source/developer_guide/feature_guide/patch.md:29
msgid ""
"**platform**: The patch code in this directory is for patching the code "
"in vLLM main process. It's called by "
"`vllm_ascend/platform::NPUPlatform::pre_register_and_update` very early "
"when vLLM is initialized."
msgstr "**platform**：此目录下的补丁代码用于修补 vLLM 主进程中的代码。vLLM 初始化时，会由 `vllm_ascend/platform::NPUPlatform::pre_register_and_update` 在极早期调用。"

#: ../../source/developer_guide/feature_guide/patch.md:30
msgid ""
"For online mode, vLLM process calls the platform patch in "
"`vllm/vllm/engine/arg_utils.py::AsyncEngineArgs.add_cli_args` when "
"parsing the cli args."
msgstr "对于在线模式，vLLM 进程在解析命令行参数时，会于 `vllm/vllm/engine/arg_utils.py::AsyncEngineArgs.add_cli_args` 处调用平台补丁。"

#: ../../source/developer_guide/feature_guide/patch.md:31
msgid ""
"For offline mode, vLLM process calls the platform patch in "
"`vllm/vllm/engine/arg_utils.py::EngineArgs.create_engine_config` when "
"parsing the input parameters."
msgstr "对于离线模式，vLLM 进程在解析输入参数时，会于 `vllm/vllm/engine/arg_utils.py::EngineArgs.create_engine_config` 处调用平台补丁。"

#: ../../source/developer_guide/feature_guide/patch.md:32
msgid ""
"**worker**: The patch code in this directory is for patching the code in "
"vLLM worker process. It's called by "
"`vllm_ascend/worker/worker::NPUWorker::__init__` when the vLLM worker "
"process is initialized."
msgstr "**worker**：此目录中的补丁代码用于修补 vLLM worker 进程中的代码。vLLM worker 进程初始化时，由 `vllm_ascend/worker/worker::NPUWorker::__init__` 调用。"

#: ../../source/developer_guide/feature_guide/patch.md:33
msgid ""
"For both online and offline mode, vLLM engine core process calls the "
"worker patch in "
"`vllm/vllm/worker/worker_base.py::WorkerWrapperBase.init_worker` when "
"initializing the worker process."
msgstr "无论在线还是离线模式，vLLM 引擎核心进程在初始化 worker 进程时，都会在 `vllm/vllm/worker/worker_base.py::WorkerWrapperBase.init_worker` 处调用 worker 补丁。"

#: ../../source/developer_guide/feature_guide/patch.md:35
msgid "How to write a patch"
msgstr "如何编写补丁"

#: ../../source/developer_guide/feature_guide/patch.md:37
msgid ""
"Before writing a patch, following the principle above, we should patch "
"the least code. If it's necessary, we can patch the code in either "
"**platform** and **worker** folder. Here is an example to patch "
"`distributed` module in vLLM."
msgstr "编写补丁前，应遵循上述原则，力求修改最少的代码。若确有必要，可在 **platform** 或 **worker** 目录中进行补丁。以下以修补 vLLM 中 `distributed` 模块为例。"

#: ../../source/developer_guide/feature_guide/patch.md:39
msgid ""
"Decide which version of vLLM we should patch. For example, after "
"analysis, here we want to patch both `0.10.0` and `main` of vLLM."
msgstr "确定需要修补的 vLLM 版本。例如，经分析后，我们决定同时为 vLLM 的 `0.10.0` 版本和 `main` 分支编写补丁。"

#: ../../source/developer_guide/feature_guide/patch.md:40
msgid ""
"Decide which process we should patch. For example, here `distributed` "
"belongs to the vLLM main process, so we should patch `platform`."
msgstr "确定需要修补的进程。例如，此处 `distributed` 模块属于 vLLM 主进程，因此应选择 `platform` 目录。"

#: ../../source/developer_guide/feature_guide/patch.md:41
#, python-brace-format
msgid ""
"Create the patch file in the right folder. The file should be named as "
"`patch_{module_name}.py`. The example here is "
"`vllm_ascend/patch/platform/patch_distributed.py`."
msgstr "在正确的文件夹中创建补丁文件。文件应命名为 `patch_{模块名}.py`。本例中为 `vllm_ascend/patch/platform/patch_distributed.py`。"

#: ../../source/developer_guide/feature_guide/patch.md:42
msgid "Write your patch code in the new file. Here is an example:"
msgstr "在新文件中编写补丁代码。示例如下："

#: ../../source/developer_guide/feature_guide/patch.md:54
msgid ""
"Import the patch file in `__init__.py`. In this example, add `import "
"vllm_ascend.patch.platform.patch_distributed` into "
"`vllm_ascend/patch/platform/__init__.py`."
msgstr "在 `__init__.py` 中导入补丁文件。此例中，需将 `import vllm_ascend.patch.platform.patch_distributed` 添加至 `vllm_ascend/patch/platform/__init__.py`。"

#: ../../source/developer_guide/feature_guide/patch.md:55
msgid ""
"Add the description of the patch in `vllm_ascend/patch/__init__.py`. The "
"description format is as follows:"
msgstr "在 `vllm_ascend/patch/__init__.py` 中添加补丁描述。描述格式如下："

#: ../../source/developer_guide/feature_guide/patch.md:71
msgid ""
"Add the Unit Test and E2E Test. Any newly added code in vLLM Ascend "
"should contain the Unit Test and E2E Test as well. You can find more "
"details in [test guide](../contribution/testing.md)"
msgstr "添加单元测试与端到端（E2E）测试。vLLM Ascend 中新增的任何代码均应包含单元测试和 E2E 测试。更多详情请参阅[测试指南](../contribution/testing.md)。"

#: ../../source/developer_guide/feature_guide/patch.md:73
msgid "Limitation"
msgstr "限制条件"

#: ../../source/developer_guide/feature_guide/patch.md:74
msgid ""
"In V1 Engine, vLLM starts three kinds of process: Main process, "
"EngineCore process and Worker process. Now vLLM Ascend only can patch the"
" code in Main process and Worker process by default. If you want to patch"
" the code running in EngineCore process, you should patch EngineCore "
"process entirely during setup. Find the entire code in "
"`vllm.v1.engine.core`. Please override `EngineCoreProc` and "
"`DPEngineCoreProc` entirely."
msgstr "在 V1 引擎中，vLLM 会启动三类进程：主进程、EngineCore 进程和 Worker 进程。目前 vLLM Ascend 默认仅支持为主进程和 Worker 进程的代码打补丁。若需为 EngineCore 进程中的代码打补丁，则需在设置阶段对整个 EngineCore 进程进行修补。完整代码位于 `vllm.v1.engine.core` 中。请完整重写 `EngineCoreProc` 和 `DPEngineCoreProc`。"

#: ../../source/developer_guide/feature_guide/patch.md:75
msgid ""
"If you are running edited vLLM code, the version of vLLM may be changed "
"automatically. For example, if you run the edited vLLM based on v0.9.n, "
"the version of vLLM may be changed to v0.9.nxxx. In this case, the patch "
"for v0.9.n in vLLM Ascend would not work as expected, because vLLM Ascend"
" can't distinguish the version of the vLLM you're using. In this case, "
"you can set the environment variable `VLLM_VERSION` to specify the "
"version of the vLLM you're using, and then the patch for v0.10.0 should "
"work."
msgstr "如果您运行的是经过编辑的 vLLM 代码，vLLM 的版本可能会被自动更改。例如，若您基于 v0.9.n 版本运行了编辑后的 vLLM，vLLM 版本可能会变为 v0.9.nxxx。此时，vLLM Ascend 中针对 v0.9.n 的补丁将无法正常工作，因为 vLLM Ascend 无法准确识别您正在使用的 vLLM 版本。这种情况下，您可以通过设置环境变量 `VLLM_VERSION` 来明确指定所使用的 vLLM 版本，随后针对 v0.10.0 的补丁即可生效。"

#~ msgid ""
#~ "In both **platform** and **worker** "
#~ "folder, there are several patch modules."
#~ " They are used for patching different"
#~ " version of vLLM."
#~ msgstr "在 **platform** 和 **worker** 文件夹中，均包含多个补丁模块，用于修补不同版本的 vLLM。"

#~ msgid ""
#~ "`patch_0_9_2`: This module is used for"
#~ " patching vLLM 0.9.2. The version is"
#~ " always the nearest version of vLLM."
#~ " Once vLLM is released, we will "
#~ "drop this patch module and bump to"
#~ " a new version. For example, "
#~ "`patch_0_9_2` is used for patching vLLM"
#~ " 0.9.2."
#~ msgstr "`patch_0_9_2`：此模块用于修补 vLLM 0.9.2。该版本始终对应 vLLM 的最新发布版本。一旦 vLLM 发布新版本，我们将弃用此补丁模块并升级至新版本。例如，`patch_0_9_2` 即专为 vLLM 0.9.2 设计。"

#~ msgid ""
#~ "`patch_main`: This module is used for"
#~ " patching the code in vLLM main "
#~ "branch."
#~ msgstr "`patch_main`：此模块用于修补 vLLM 主分支代码。"

#~ msgid ""
#~ "`patch_common`: This module is used for"
#~ " patching both vLLM 0.9.2 and vLLM"
#~ " main branch."
#~ msgstr "`patch_common`：此模块用于同时修补 vLLM 0.9.2 版本和 vLLM 主分支。"